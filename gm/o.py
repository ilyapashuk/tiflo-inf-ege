# Здесь находится код, общий для всех трех заданий 19-21. Он пишется один раз, затем повторно используется.

# Функция, задающая условие выигрыша. Зависит от условия конкретной задачи.
def check(k): return k >= 129

# Функция, задающая возможные варианты хода. Зависит от условия задачи.
def step(k):
	return (k + 1, k * 2)


# Рекурсивный алгоритм, выполняющий вычисления. От условия задачи не зависит, воспроизвести и запомнить.
# проверяет наличие возможности гарантированного выигрыша при данных исходных параметрах, то есть наличие у одного из игроков стратегии, которая позволит ему выиграть независимо от игры противника.
# параметры:
# k: начальная позиция
# n: при вызове передавать 0
# sw: указывает, какой из игроков должен выиграть. передавать True, если выиграть должен игрок, совершающий первый ход, иначе False.
# lim: максимально допустимое количество ходов: выводить из условия задачи
# возврат: True, если есть хотя бы одна подходящая стратегия, иначе False
def g(k,n,sw,lim):
	if check(k): return not sw
	if n >= lim: return False
	r = [g(kk,n + 1, not sw, lim) for kk in step(k)]
	cmp = None
	if sw: cmp = any
	else: cmp = all
	return cmp(r)


# функция gg проверяет не возможность гарантированного выигрыша, как предыдущая функция, а наличие хотя бы одной выигрышной комбинации (формулировка "такая ситуация возможна").
# получается копированием и модификацией первой функции

# схема задания параметров та же, что и у первой функции
def gg(k,n,sw,lim):
	if check(k): return not sw
	if n >= lim: return False
	r = [gg(kk,n + 1, not sw, lim) for kk in step(k)]
	cmp = any
	return cmp(r)